/* Generated by Together */

#include "stdafx.h"
#include "resource.h"
#include "CRing.h"
#include "CCcrPatt.h"
#include "DefineCircular.h"
#include "DefineCircularSegment.h"
#include "MPoint.h"
#include <math.h>

CCcrPatt::CCcrPatt()/* : CPattern(_T("Circular Pattern"))*/
{
	/*
		magic = 0;

		magic = 1;
		CRing * r = new CRing;
		r->radius = 20;
		r->npoint = 8;
		r->angle = 0;
		rings.AddTail(r);

		r = new CRing;
		r->radius = 50;
		r->npoint = 8;
		r->angle = 20;
		rings.AddTail(r);

		r = new CRing;
		r->radius = 65;
		r->npoint = 12;
		r->angle = 9;
		rings.AddTail(r);
	*/
	pPatt = NULL;
}

CCcrPatt::~CCcrPatt() {
	ClearList();
}

CCcrPatt& CCcrPatt::operator = (CCcrPatt& CcrPatt) {
	//	CPattern::operator =(CcrPatt);
	ClearList();
	for (int i = 0; i < CcrPatt.rings.GetCount(); i++) {
		CRing* l = new CRing;
		if (l) {
			*l = *CcrPatt.GetRing(i);
			rings.AddTail(l);
		}
	}
	return *this;
}

void CCcrPatt::ClearList() {
	POSITION pos = rings.GetHeadPosition();
	while (pos) {
		CRing* p = (CRing*)rings.GetNext(pos);
		if (p) delete p;
	}
	if (rings.GetCount()) {
		rings.RemoveAll();
	}

	if (pPatt) pPatt->MP.Clear();
}

int CCcrPatt::GetNRing() {
	return rings.GetCount();
}

CRing* CCcrPatt::GetRing(int n) {
	return (CRing*)rings.GetAt(rings.FindIndex(n));
}

void CCcrPatt::Serialize(CArchive& ar) {
	short magic;
	if (ar.IsStoring()) {
		magic = 2;
		ar << magic;
		short n = (short)rings.GetCount();
		ar << n;
		if (n > 0) {
			POSITION pos = rings.GetHeadPosition();
			while (pos) {
				CRing* p = (CRing*)rings.GetNext(pos);
				if (p) p->Serialize(ar);
			}
		}
		//        dmy.MP.Serialize(ar);
	}
	else {
		ClearList();
		ar >> magic;
		short n;
		ar >> n;
		for (int i = 0; i < n; i++) {
			CRing* p = new CRing;
			if (p) {
				p->Serialize(ar);
				rings.AddTail(p);
			}
		}
		if (magic < 2) {
			if (pPatt) pPatt->MP.Serialize(ar);
		}
	}
}

void CCcrPatt::SetData(CPtrList& rgs) {
	ClearList();
	POSITION pos = rgs.GetHeadPosition();
	while (pos) {
		CRing* p = (CRing*)rgs.GetNext(pos);
		if (p) {
			CRing* p1 = new CRing;
			if (!p1) return;
			*p1 = *p;
			rings.AddTail(p1);
		}
	}
}

BOOL CCcrPatt::SetUp(CWnd*) {
	CDefineCircular dlg;
	if (dlg.DoModal() == IDOK) {
		SetData(dlg.rings);
		return TRUE;
	}
	return FALSE;
}

BOOL CCcrPatt::SetUpSeg(CWnd*) {
	CDefineCircularSegment dlg;
	if (dlg.DoModal() == IDOK) {
		SetData(dlg.rings);
		return TRUE;
	}
	return FALSE;
}

BOOL CCcrPatt::Generate(float) {
	if (!pPatt) {
		return FALSE;
	}
	pPatt->MP.Clear();
	short idx = 1;
	int n = GetNRing();
	for (int a = 0; a < n; a++) {
		CRing* l = GetRing(a);
		if (!l) break;
		if (l->npoint < 1) continue;
		if (l->radius2 == 0) {
			float sf = 360.f / l->npoint;
			for (int i = 0; i < l->npoint; i++) {
				float angle = float((l->angle + i * sf) * PIE180);
				float xx = float((l->radius) * cos(angle));
				float yy = float((l->radius) * sin(angle));
				pPatt->AddMPoint(idx, xx, yy, 0/*, 0 ,0*/);
				idx++;
			}
		}
		else {
			float dr = (l->radius2 - l->radius) / float(l->npoint);
			for (int i = 0; i < l->npoint; i++) {
				float xx = float((l->radius + dr * i) * cos(l->angle * PIE180));
				float yy = float((l->radius + dr * i) * sin(l->angle * PIE180));
				pPatt->AddMPoint(idx++, xx, yy, 0/*, 0 ,0*/);
			}
		}
	}

	return (0 < idx);
}

BOOL CCcrPatt::Generate2(int, int, float, float, float, float, float) {
	return TRUE;
}

void CCcrPatt::DrawPattern(CDC* pDC, const CRect& rect, float fRatio) {
	CPen pen, * ppen;
	pen.CreatePen(PS_SOLID, 1, RGB(32, 200, 32));
	ppen = pDC->SelectObject(&pen);
	CBrush* pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);

	CPoint cpt = rect.CenterPoint();
	int n = GetNRing();
	for (int a = 0; a < n; a++) {
		CRing* l = GetRing(a);
		if (!l) break;

		int r = (int)(l->radius * fRatio);
		pDC->Ellipse(cpt.x - r, cpt.y - r, cpt.x + r, cpt.y + r);
	}
	pDC->SelectObject(pOldBrush);
}