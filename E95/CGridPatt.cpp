/* Generated by Together */

#include "stdafx.h"
#include "resource.h"
#include "MPoint.h"
#include "CGridPatt.h"
#include "DefineGrid.h"
#include "ChuckMask.h"

#include <math.h>
#include "MainFrm.h"

#include "413App.h"

#define sqr(x) ((x)*(x))

CGridPatt::CGridPatt() /*: CPattern(_T("Grid Pattern"))*/
{
	//    magic = 2;
	ngrid = 0;
	ngridY = 5.f;
	ngridX = 5.f;
	bClearData = FALSE;
	bUseMask = FALSE;
	pPatt = NULL;
}

CGridPatt::~CGridPatt() {
	if (pPatt) pPatt->MP.Clear();
}

CGridPatt& CGridPatt::operator = (CGridPatt& GridPatt) {
	//	CPattern::operator=(GridPatt);
	ngrid = GridPatt.ngrid;
	//MP = GridPatt.MP;
	ngridY = GridPatt.ngridY;
	ngridX = GridPatt.ngridX;
	return *this;
}

// Version 2 added grid in Y direction
// Version 3 added grid in X direction
void CGridPatt::Serialize(CArchive& ar) {
	short magic;
	short dummy = 0;
	if (ar.IsStoring()) {
		magic = 4;
		ar << magic;
		ar << ngrid;
		//        dmy.MP.Serialize(ar);
		ar << ngridY;
		ar << ngridX;
	}
	else {
		ar >> magic;
		ar >> ngrid;
		if (magic < 4) {
			if (pPatt) pPatt->MP.Serialize(ar);
		}
		if (magic < 2) {
			ngridX = ngridY = ngrid;
			return;
		}
		if (magic == 2) {
			ar >> dummy;
		}
		if (magic < 3) {
			ngridX = ngrid;
			ngridY = dummy;
			return;
		}
		ar >> ngridY;
		ar >> ngridX;
	}
}

BOOL CGridPatt::Generate(float fDiameter) {
	if (!pPatt) {
		return FALSE;
	}
	if (bClearData) {
		pPatt->MP.Clear();
	}
	CChuckMask* pChuckMask = p413App->Global.GetChuckMask();

	int Index = pPatt->MP.GetCount();
	float XPitch = fDiameter / (2 * (ngridX / 2) + 1), YPitch = fDiameter / (2 * (ngridY / 2) + 1);
	if (bUseMask && pChuckMask) {
		XPitch = pChuckMask->GetXPitch();
		YPitch = pChuckMask->GetYPitch();
	}
	for (int iX = (int)-ngridX / 2; iX <= (int)ngridX / 2; iX++) {
		for (int iY = (int)-ngridY / 2; iY <= (int)ngridY / 2; iY++) {
			float XCenter = iX * XPitch;
			float YCenter = iY * YPitch;
			float dist = (float)sqrt(sqr(XCenter) + sqr(YCenter));
			if (dist < fDiameter / 2) {
				if (bUseMask && pChuckMask) {
					pChuckMask->GetCenter(XCenter, YCenter);
				}
				if (!pPatt->IsPointDefined(XCenter, YCenter)) {
					pPatt->AddMPoint(Index++, XCenter, YCenter, 0/*,0,0*/);
				}
			}
		}
	}
	return Index > 0;
}
// [ Morsalin
BOOL CGridPatt::Generate3(float fDiameter, float waferRadius, BOOL edgeExclude) {

	
	int idx = 1, ind = 1;
	float x, y, bx, by, Ax, Ay;
	/*float m_Radius = 150.00;*/

	// Anchor point [6/19/2013 Yuen]
	Ax = 0;
	Ay = 0;

	//dX.x = (pRcp->XYPair[2].x - pRcp->XYPair[0].x);
	//dX.x = offset; //Commented by Morsalin
	dX.x = p413App->Global.DieWidth;
	//dX.y = (pRcp->XYPair[2].y - pRcp->XYPair[0].y); //0 
	dX.y = 0; //0 
	//dY.y = (pRcp->XYPair[1].y - pRcp->XYPair[0].y);
	dY.y = p413App->Global.DieHeight;
	//dY.y = (pRcp->XYPair[1].y - pRcp->XYPair[0].y);
	dY.x = 0;

	if (dX.x <= 2) { // 11102025 MORSALIN
		return FALSE;
	}
	if (dY.y <= 2) { // 11102025 MORSALIN
		return FALSE;
	}

	short szX = 50;
	short szY = 50;
	for (int j = -szY; j <= szY; j++)  // y direction [3/10/2011 FSMT]
	{
		for (int i = -szX; i <= szX; i++) // x direction [3/10/2011 FSMT]
		{
			x = Ax + i * dX.x + j * dY.x;
			y = Ay + j * dY.y + i * dX.y;
			bx = x; by = y;
			float dist1 = (float)sqrt(x * x + y * y);
			x += dX.x; y += dX.y;
			float dist2 = (float)sqrt(x * x + y * y);
			y += dY.y; x += dY.x;
			float dist3 = (float)sqrt(x * x + y * y);
			x -= dX.x; y -= dX.y;
			float dist4 = (float)sqrt(x * x + y * y);

			short cnt = 0;
			BOOL bFirst = FALSE;
			if (dist1 <= waferRadius) {
				//bFirst = TRUE;
				cnt++;
			}
			if (dist2 <= waferRadius) {
				cnt++;
			}
			if (dist3 <= waferRadius) {
				cnt++;
			}
			if (dist4 <= waferRadius) {
				cnt++;
			}

			if (cnt > 0) {
				if (!p413App->Global.m_bIncludeOn && (cnt != 4)) {
					continue;
				}
				//SetCellItem(idx, bx, by);
				float xx, yy, x18, y18, x19, y19;

				float x1 = 00.00, y1 = 0.00;// bottom left corner
				float x2 = 0.00, y2 = 0.00;// top right corner
				x1 = bx;
				//y1 = by - dY.y;
				y1 = by;
				x2 = bx + dX.x;
				y2 = by + dY.y;

				// [ Morsalin
				float dieMidX = (x2 + x1)/2;
				float dieMidY = (y2 + y1)/2;
				float distanceFromCenter1 = sqrt((x1 * x1) + (y1 * y1));
				float distanceFromCenter2 = sqrt((x2 * x2) + (y1 * y1));
				float distanceFromCenter3 = sqrt((x2 * x2) + (y2* y2));
				float distanceFromCenter4 = sqrt((x1 * x1) + (y2 * y2));

				
				CCoor p;
				p.n = ind++;
				p.x = dieMidX;
				p.y = dieMidY;
				
				if (!edgeExclude)
				{
					if (waferRadius >= distanceFromCenter1 && waferRadius >= distanceFromCenter2 &&
						waferRadius >= distanceFromCenter3 && waferRadius >= distanceFromCenter4)
					{
						pPatt->AddMPoint(p);
					}
					else
						ind--;
				}
				else 
					pPatt->AddMPoint(p);
				//pPatt->AddMPoint(idx-1, dieMidX, dieMidY/*,0,0*/);
				// ]
				idx++;
			}
		}
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//pPatt->AddMPoint(0, ngridX, ngridY, 0/*,0,0*/);
	//pPatt->AddMPoint(0, 60, 60, 0/*,0,0*/);

	return TRUE;
}
// ]

BOOL CGridPatt::Generate2(int NX, int NY, float X0, float Y0, float sizeX, float sizeY, float fDiameter, BOOL bIgnore) {
	if (!pPatt) {
		return FALSE;
	}
	CChuckMask* pChuckMask = p413App->Global.GetChuckMask();
	// 	char inifile[_MAX_PATH];
	// 	char drive[_MAX_DRIVE];
	// 	char dir[_MAX_DIR];
	// 	char fname[_MAX_FNAME];
	// 	char ext[_MAX_EXT];
	// 	GetModuleFileName(NULL, inifile, _MAX_PATH);
	// 	_splitpath(inifile, drive, dir, fname, ext);
	// 	_makepath(inifile, drive, dir, "FSMLocalCfg", "ini");

	// 	char str[255];
	// 	sprintf(str, "%.2f", 0.0f);
	// 	GetPrivateProfileString("Echo", "Probe1XOffset", str, str, 255, inifile);
	// 	float fProbe1XOffset = atof(str);
	// 	sprintf(str, "%.2f", 0.0f);
	// 	GetPrivateProfileString("Echo", "Probe1YOffset", str, str, 255, inifile);
	// 	float fProbe1YOffset = atof(str);
	// 	sprintf(str, "%.2f", 0.0f);
	// 	GetPrivateProfileString("Echo", "Probe2XOffset", str, str, 255, inifile);
	// 	float fProbe2XOffset = atof(str);
	// 	sprintf(str, "%.2f", 0.0f);
	// 	GetPrivateProfileString("Echo", "Probe2YOffset", str, str, 255, inifile);
	// 	float fProbe2YOffset = atof(str);

	int Index = pPatt->MP.GetCount();
	if ((NX > 0) && (NY > 0)) {
		float XPitch, YPitch;
		if (NX > 1) {
			XPitch = sizeX / (NX - 1);
		}
		else {
			XPitch = 0;
		}
		if (NY > 1) {
			YPitch = sizeY / (NY - 1);
		}
		else {
			YPitch = 0;
		}
		for (int iX = -NX / 2; iX <= NX / 2; iX++) {
			for (int iY = -NY / 2; iY <= NY / 2; iY++) {
				float XCenter = X0 + iX * XPitch;
				float YCenter = Y0 + iY * YPitch;

				float dist = (float)sqrt(sqr(XCenter) + sqr(YCenter));
				if (dist < fDiameter / 2) {
					if (bIgnore || !pPatt->IsPointDefined(XCenter, YCenter)) {
						pPatt->AddMPoint(Index++, XCenter, YCenter, 0/*,0,0*/);
						// 							CRecipeView* pView = (CRecipeView*) Global.GetMainFrame()->GetRecipeView();
						// 							if (pView)
						// 							{
						// 								if ((Global.bAddProbes)&&(pView->m_bAddPoints))
						// 								{
						// 									AddMPoint(Index,XCenter+fProbe1XOffset,YCenter+fProbe1YOffset,Index++, fProbe1XOffset, fProbe1YOffset);
						// 									AddMPoint(Index,XCenter+fProbe2XOffset,YCenter+fProbe2YOffset,Index++, fProbe2XOffset, fProbe2YOffset);
						// 								}
						// 							}
					}
				}
			}
		}
	}
	return Index > 0;
}

BOOL CGridPatt::SetUp(CWnd* pWnd) {
	CDefineGrid dlg(pWnd);
	dlg.m_lineX = ngridX;
	dlg.m_lineY = ngridY;
	dlg.m_DeletePrev = bClearData;
	dlg.m_UseMask = bUseMask;
	if (dlg.DoModal() == IDOK) {
		ngridX = dlg.m_lineX;
		ngridY = dlg.m_lineY;
		bClearData = dlg.m_DeletePrev;
		bUseMask = dlg.m_UseMask;
		if (pPatt) {
			pPatt->bUseMask = bUseMask;
		}
		return TRUE;
	}
	return FALSE;
}

void CGridPatt::DrawPattern(CDC* pDC, const CRect& rect, float) {
	CPen pen, * ppen;
	pen.CreatePen(PS_SOLID, 1, RGB(32, 200, 32));
	ppen = (CPen*)pDC->SelectObject(&pen);

	int i, gd;
	gd = (int)GetGridX();
	if (0 < gd) {
		for (i = 0; i <= gd; i++) {
			int nX = rect.left + (rect.Width() * i) / gd;
			pDC->MoveTo(nX, rect.top);
			pDC->LineTo(nX, rect.bottom);
		}
	}

	gd = (int)GetGridY();
	if (0 < gd) {
		for (i = 0; i <= gd; i++) {
			int nY = rect.top + (rect.Height() * i) / gd;
			pDC->MoveTo(rect.left, nY);
			pDC->LineTo(rect.right, nY);
		}
	}

	if (ppen) pDC->SelectObject(ppen);
}

void CGridPatt::ClearList() {
	if (pPatt) pPatt->MP.Clear();
}