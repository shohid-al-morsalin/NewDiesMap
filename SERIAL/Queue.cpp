/* Generated by Together */

#include "stdafx.h"
#include "Queue.h"
#include "MsgItem.h"

void CQueue::Clear() {
	CSingleLock Lock(&CS);
	if (Lock.Lock()) {
		POSITION pos;
		pos = pList.GetHeadPosition();
		while (pos) {
			CMsgItem* p = (CMsgItem*)pList.GetNext(pos);
			if (p) {
				delete p;
			}
		}
		pList.RemoveAll();
	}
}

CRtnCode::RCODE CQueue::AddHead(CMsgItem* pMsg) {
	CSingleLock Lock(&CS);
	if (Lock.Lock()) {
		if (pList.GetCount() > 1024) {
			// Buffer overflow
			ASSERT(0);
			return CRtnCode::ERR;
		}
		pMsg->IDIdx = index++;
		pList.AddHead(pMsg);
		return CRtnCode::NOERR;
	}
	return CRtnCode::ERR;
}

CMsgItem* CQueue::RemoveHead() {
	CSingleLock Lock(&CS);
	if (Lock.Lock()) {
		if (pList.GetCount() > 0) {
			return (CMsgItem*)pList.RemoveHead();
		}
	}
	return NULL;
}

CRtnCode::RCODE CQueue::AddTail(CMsgItem* pMsg) {
	CSingleLock Lock(&CS);
	if (Lock.Lock()) {
		if (pList.GetCount() > 1024) {
			// Buffer overflow
			ASSERT(0);
			return CRtnCode::ERR;
		}
		pMsg->IDIdx = index++;
		pList.AddTail(pMsg);
		return CRtnCode::NOERR;
	}
	return CRtnCode::ERR;
}

//	CMsgItem * RemoveTail();

CQueue::CQueue() {
	index = 1;
}

CQueue::~CQueue() {
	Clear();
}

int CQueue::GetCount(void) {
	CSingleLock Lock(&CS);
	if (Lock.Lock()) {
		return (int)pList.GetCount();
	}
	return 0;
}

CMsgItem* CQueue::Remove(short ID) {
	CSingleLock Lock(&CS);
	if (Lock.Lock()) {
		POSITION opos;
		POSITION pos = pList.GetHeadPosition();
		while (pos) {
			opos = pos;
			CMsgItem* p = (CMsgItem*)pList.GetNext(pos);
			if (p) {
				if (p->IDIdx == ID) {
					pList.RemoveAt(opos);
					return p;
				}
			}
		}
	}
	return NULL;
}

CRtnCode::RCODE CQueue::AddT(CMsgItem* pMsg) {
	CSingleLock Lock(&CS);
	if (Lock.Lock()) {
		if (pList.GetCount() > 1024) {
			// Buffer overflow
			ASSERT(0);
			return CRtnCode::ERR;
		}
		pList.AddTail(pMsg);
		return CRtnCode::NOERR;
	}
	return CRtnCode::ERR;
}

CRtnCode::RCODE CQueue::AddH(CMsgItem* pMsg) {
	CSingleLock Lock(&CS);
	if (Lock.Lock()) {
		if (pList.GetCount() > 1024) {
			// Buffer overflow
			ASSERT(0);
			return CRtnCode::ERR;
		}
		pList.AddHead(pMsg);
		return CRtnCode::NOERR;
	}
	return CRtnCode::ERR;
}