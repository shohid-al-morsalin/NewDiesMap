/* Generated by Together */

#include "stdafx.h"
#include "MsgItem.h"
#include "..\SRC\BMake.h"

CMsgItem::CMsgItem() {
	Len = 0;
	IDIdx = 0;
	bRpy = FALSE;
	DataTyp = SIMPLEDATA;
	DataID = IDNONE;
	MsgSrc = MSNONE;
	MsgDes = MDNONE;
	MsgEvent = MENONE;
	pMsg = NULL;
	AckWnd = 0;
	Ack = 0;
	Nak = 0;
	Ret = 0;
	hEvent = 0;
	Unit = 0;
	STSLocFrom = NOTDEF;
	STSLocTo = NOTDEF;
	pSTSSubstObj = NULL;
}

CMsgItem::~CMsgItem() {
	if (pSTSSubstObj) {
		delete pSTSSubstObj;
		pSTSSubstObj = NULL;
	}
	if (hEvent) {
		CloseHandle(hEvent);
	}
	if (pMsg) {
		delete[] pMsg;
	}
}

short CMsgItem::Alloc(int size) {
	if (pMsg) {
		delete[] pMsg;
	}
	pMsg = new char[size];
	if (pMsg) {
		return 1;
	}
	return 0;
}

CRtnCode::RCODE CMsgItem::SetAlloc(char* msg, int len) {
	if (Alloc(len + 2)) {
		memcpy(pMsg, msg, len + 1);
		*(pMsg + len) = 0;	// Terminate char stream
		Len = len;
		return CRtnCode::NOERR;
	}
	return CRtnCode::ERR;
}

long CMsgItem::GetSize() {
	long sz = 0;

	sz += sizeof(Len);
	sz += sizeof(IDIdx);
	sz += sizeof(bRpy);
	sz += Len + 1;		// for pMsg, +1 to terminate with \0
	sz += sizeof(Unit);
	sz += sizeof(AckWnd);
	sz += sizeof(Ack);
	sz += sizeof(Nak);
	sz += sizeof(Ret);
	sz += sizeof(MsgEvent);
	sz += sizeof(MsgDes);
	sz += sizeof(DataTyp);
	sz += sizeof(DataID);
	sz += sizeof(MsgSrc);
	sz += sizeof(STSLocFrom);
	sz += sizeof(STSLocTo);
	sz += sizeof(Len);	// size of pSTSSubstObj, 0 if pSTSSubstObj is NULL
	if (pSTSSubstObj) {
		sz += sizeof(CSubstObj);	// size of SubsObj
	}
	sz += 16; // security

	return sz;
}

BOOL CMsgItem::Conv(char* msg) {
	CMake::Conv(Len, &msg);
	CMake::Conv(IDIdx, &msg);
	CMake::Conv(bRpy, &msg);
	CMake::Conv(Unit, &msg);
	CMake::Conv(AckWnd, &msg);
	CMake::Conv(Ack, &msg);
	CMake::Conv(Nak, &msg);
	CMake::Conv(Ret, &msg);
	CMake::Conv(MsgEvent, &msg);
	CMake::Conv(MsgDes, &msg);
	CMake::Conv(DataTyp, &msg);
	CMake::Conv(DataID, &msg);
	CMake::Conv(MsgSrc, &msg);
	if (Len > 0) {
		if (pMsg) {
			delete[] pMsg;
		}
		pMsg = new char[Len + 1];
		memcpy(pMsg, msg, Len);
		pMsg[Len] = 0;
		msg += Len;
	}
	if (Len < 0) {
		ASSERT(0);
	}
	CMake::Conv(STSLocFrom, &msg);
	CMake::Conv(STSLocTo, &msg);
	if (pSTSSubstObj) {
		delete pSTSSubstObj;
		pSTSSubstObj = NULL;
	}
	int ObjSize = 0;
	CMake::Conv(ObjSize, &msg);
	if (ObjSize) {
		pSTSSubstObj = new CSubstObj;
		memcpy(pSTSSubstObj, msg, ObjSize);
	}
	return TRUE;
}

long CMsgItem::Binary(char* msg) {
	long sz = 0;
	sz += CMake::Binary(Len, &msg);
	sz += CMake::Binary(IDIdx, &msg);
	sz += CMake::Binary(bRpy, &msg);
	sz += CMake::Binary(Unit, &msg);
	sz += CMake::Binary(AckWnd, &msg);
	sz += CMake::Binary(Ack, &msg);
	sz += CMake::Binary(Nak, &msg);
	sz += CMake::Binary(Ret, &msg);
	sz += CMake::Binary(MsgEvent, &msg);
	sz += CMake::Binary(MsgDes, &msg);
	sz += CMake::Binary(DataTyp, &msg);
	sz += CMake::Binary(DataID, &msg);
	sz += CMake::Binary(MsgSrc, &msg);
	sz += Len;
	if (Len) {
		memcpy(msg, pMsg, Len);
		msg[Len] = 0;
		msg += (Len);
	}
	if (Len < 0) {
		ASSERT(0);
	}
	sz += CMake::Binary(STSLocFrom, &msg);
	sz += CMake::Binary(STSLocTo, &msg);
	int ObjSize = 0;
	if (pSTSSubstObj) {
		ObjSize = sizeof(CSubstObj);
		sz += CMake::Binary(ObjSize, &msg);
		memcpy(msg, pSTSSubstObj, ObjSize);
		msg += ObjSize;
		sz += ObjSize;
	}
	else {
		sz += CMake::Binary(ObjSize, &msg);
	}

	return sz;
}

long CMsgItem::GetLength() {
	return GetSize();
}

BOOL CMsgItem::Set(CString msg) {
	if (!msg || msg.GetLength() < 1) {
		Len = 0;
		return FALSE;
	}
	if (pMsg) {
		delete[] pMsg;
	}
	Len = msg.GetLength() + 1;
	pMsg = new char[Len + 16];
	if (pMsg) {
		memset(pMsg, 0, Len + 16);
		memcpy(pMsg, msg.GetBuffer(0), Len);
		return TRUE;
	}
	Len = 0;
	return FALSE;
}

BOOL CMsgItem::Set(CSMOL& SM) {
	if (pMsg) {
		delete[] pMsg;
	}
	Len = sizeof(CSMOL);
	pMsg = new char[Len + 16];
	if (pMsg) {
		memcpy(pMsg, &SM, sizeof(CSMOL));
		return TRUE;
	}
	Len = 0;
	return FALSE;
}

BOOL CMsgItem::Get(CString& str) {
	if (Len) {
		if (pMsg) {
			str = pMsg;
			return TRUE;
		}
		else {
			ASSERT(0);
		}
	}
	str = "";
	return FALSE;
}