/* Generated by Together */

#include "stdafx.h"
#include "SMSvr.h"
#include "SMOL.h"
#include "SMHdr.h"

BOOL CSMSvr::WriteSM(CSMOL* p) {
	long size = sizeof(CSMOL);
	if (size > smsize1) {
		return FALSE;
	}
	if (pSM && (size > 0)) {
		memcpy(pSM, p, size);
		return TRUE;
	}
	return FALSE;
}

BOOL CSMSvr::WriteSM(CSMHdr* p) {
	long size = sizeof(CSMHdr);
	if (size > smsize1) {
		return FALSE;
	}
	if (pSM && (size > 0)) {
		memcpy(pSM, p, size);
		return TRUE;
	}
	return FALSE;
}

BOOL CSMSvr::RdMsg(CSMOL* p, long wait) {
	return CSMIpc::Read(p, sizeof(CSMOL), wait);
}

BOOL CSMSvr::RdMsg(CSMHdr* p, long wait) {
	return CSMIpc::Read(p, sizeof(CSMHdr), wait);
}

BOOL CSMSvr::Start2(CString app, long size) {
	//CString str;
	//str.Format("Start %s thread\n", app);
	//TRACE0(str);
	return CreateSM2(app, size);
}

BOOL CSMSvr::Start1(CString app, long size) {
	//CString str;
	//str.Format("Start %s thread\n", app);
	//TRACE0(str);
	return CreateSM(app, size);
}

CSMSvr::~CSMSvr() {}

CSMSvr::CSMSvr() {
	bServer = TRUE;
}

int CSMSvr::GetCount() {
	return strlist.GetCount();
}

CString CSMSvr::RemoveHead() {
	CString str = "";
	CSingleLock Lock(&CS);
	Lock.Lock();
	str = strlist.RemoveHead();
	return str;
}

void CSMSvr::Message(CString msg) {
	CSingleLock Lock(&CS);
	Lock.Lock();
	if (strlist.GetCount() < 256) {
		strlist.AddTail(msg);
	}
	else {
		strlist.RemoveHead();
		strlist.AddTail(msg);
	}
}

void CSMSvr::Quit() {
	Done();
}