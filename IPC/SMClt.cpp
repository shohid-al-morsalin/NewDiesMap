/* Generated by Together */

#include "stdafx.h"
#include "SMClt.h"
#include "SMOL.h"
#include "SMHdr.h"
#include "SvrThread.h"

BOOL CSMC::Start(CSvrThread* pSvr, long size) {
	while (!pSvr->bStarted) {
		Sleep(10);
	}
	BOOL ret = OpenSM(pSvr->SvrName, size);
	if (ret) {
		bStarted = TRUE;
	}
	else {
		ASSERT(0);
	}
	return ret;
}

BOOL CSMC::Start2(CString app, long size, BOOL bAssert) {
	BOOL ret = OpenSM2(app, size);
	if (ret) {
		bStarted = TRUE;
	}
	else {
		if (bAssert) {
			ASSERT(0);
		}
	}
	return ret;
}

BOOL CSMC::Start1(CString app, long size, BOOL bAssert) {
	BOOL ret = OpenSM(app, size);
	if (ret) {
		bStarted = TRUE;
	}
	else {
		//		if (bAssert) ASSERT(0);
	}
	return ret;
}

CSMC::~CSMC() {}

CSMC::CSMC() {
	bStarted = FALSE;
	bServer = FALSE;
}

// Send by client to terminate host
BOOL CSMC::EndHdr() {
	ASSERT(bStarted);
	CSMHdr SM;
	SM.cmd = CSMHdr::CTEXIT;
	// Must make sure that the thread really terminate
	BOOL ret = Send(&SM, sizeof(CSMHdr), 30000);
	ASSERT(ret);
	bStarted = FALSE;
	//Sleep(200);  // wait for Window to take care of memory deallocation
	return ret;
}

// Send by client to terminate host
BOOL CSMC::EndOL() {
	ASSERT(bStarted);
	CSMOL SM;
	SM.cmd = CSMOL::cmdTERMINATE;
	// Must make sure that the thread really terminate
	BOOL ret = Send(&SM, sizeof(CSMOL), 30000);
	ASSERT(ret);
	bStarted = FALSE;
	//Sleep(200);  // wait for Window to take care of memory deallocation
	return ret;
}

BOOL CSMC::StartSvrThread(CWinThread* pThread, int priority) {
	if (pThread) {
		if (pThread->CreateThread(CREATE_SUSPENDED)) {
			pThread->SetThreadPriority(priority);
			VERIFY(pThread->ResumeThread());
			return TRUE;
		}
	}
	return FALSE;
}

BOOL CSMC::StopSvrThread(CString svr, short type) {
	// 	HANDLE hDone; // Server informs client mutex
	// 	hDone =::CreateEvent(NULL, TRUE, FALSE, svr + "Kill");
	// 	if (!hDone)
	// 	{
	// 		ASSERT(0);
	// 		return FALSE;
	// 	}
	CSMC ipc;
	BOOL ret = FALSE;
	switch (type) {
	case 1:
		if (ipc.Start1(svr, sizeof(CSMOL))) {
			ret = ipc.EndOL();
			Sleep(10); // For reliability: Let SvrThread has a chance to execute
		}
		// 			WaitForSingleObject(hDone, 120000);
		// 			CloseHandle(hDone);
		return ret;
		break;
	case 2:
		if (ipc.Start1(svr, sizeof(CSMHdr))) {
			ret = ipc.EndHdr();
			Sleep(10); // For reliability: Let SvrThread has a chance to execute
		}
		// 			WaitForSingleObject(hDone, 120000);
		// 			CloseHandle(hDone);
		return ret;
		break;
	}
	return FALSE;
}